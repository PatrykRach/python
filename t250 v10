import re
import json
import difflib
import requests
from bs4 import BeautifulSoup
from googlesearch import search
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# === Ścieżka pliku do zapisywania feedbacku ===
FEEDBACK_FILE = "feedback.json"

# === Czyszczenie tekstu z niepotrzebnych znaków ===
def clean_text(text):
    return re.sub(r'[^\w\s]', '', text.lower().strip())

# === Ładowanie bazy feedbacku ===
def load_feedback():
    try:
        with open(FEEDBACK_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"good": {}, "bad": {}}

# === Zapis feedbacku do pliku ===
def save_feedback(data):
    with open(FEEDBACK_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

# === Szukanie podobnych zapytań (uczenie się) ===
def find_similar_question(query, known_questions):
    for q in known_questions:
        ratio = difflib.SequenceMatcher(None, clean_text(q), clean_text(query)).ratio()
        if ratio > 0.8:
            return q
    return None

# === Pobieranie treści z wyników wyszukiwania ===
def fetch_results(query):
    results = []
    try:
        for url in search(query, num_results=5):
            try:
                page = requests.get(url, timeout=5)
                soup = BeautifulSoup(page.text, "html.parser")
                for p in soup.find_all("p"):
                    text = p.get_text().strip()
                    if 30 < len(text) < 500:
                        results.append(text)
            except:
                continue
    except:
        print(" Błąd podczas wyszukiwania w Google.")
    return results

# === Wybieranie najlepszych 5 odpowiedzi ===
def best_answers(query, paragraphs):
    vect = TfidfVectorizer().fit_transform([query] + paragraphs)
    similarities = cosine_similarity(vect[0:1], vect[1:]).flatten()
    top_indices = similarities.argsort()[-5:][::-1]
    return [paragraphs[i] for i in top_indices]

# === Podsumowanie odpowiedzi (najdłuższa) ===
def podsumuj(answers):
    return max(answers, key=len)

# === Sprawdzanie czy zapytanie ma sens ===
def zapytanie_ma_sens(query):
    cleaned = clean_text(query)
    if len(cleaned.split()) < 2:
        return False
    if re.fullmatch(r"[a-zA-Z0-9\s]+", cleaned) is None:
        return False
    return True

# === Główna funkcja odpowiadająca na pytania ===
def inteligentna_odpowiedz(query):
    if not zapytanie_ma_sens(query):
        print(" Podaj pełne i sensowne pytanie (min. 2 słowa, bez samych znaków).")
        return

    feedback = load_feedback()

    # Szukamy podobnych pytań
    podobne_dobre = find_similar_question(query, feedback["good"])
    if podobne_dobre:
        print(" Odpowiedź na podobne pytanie z bazy wiedzy:")
        odp = feedback["good"][podobne_dobre]
        for a in odp["answers"]:
            print(f"- {a}")
        print(" Podsumowanie:", odp["summary"])
        return

    # Jeśli nie ma podobnych, wyszukaj z internetu
    results = fetch_results(query)
    if not results:
        print(" Nie udało się znaleźć odpowiedzi.")
        return

    answers = best_answers(query, results)
    summary = podsumuj(answers)

    print(" Najtrafniejsze odpowiedzi:")
    for a in answers:
        print(f"- {a}")
    print("\n Podsumowanie:", summary)

    # Feedback użytkownika
    ocena = input("\nCzy ta odpowiedź była przydatna? (tak/nie): ").strip().lower()
    if ocena == "tak":
        feedback["good"][query] = {
            "answers": answers,
            "summary": summary
        }
    elif ocena == "nie":
        feedback["bad"][query] = {
            "answers": answers,
            "summary": summary
        }

    save_feedback(feedback)

# === Uruchomienie programu ===
if __name__ == "__main__":
    while True:
        zapytanie = input("Zadaj pytanie (lub wpisz 'koniec' aby zakończyć): ")
        if zapytanie.lower() == "koniec":
            break
        inteligentna_odpowiedz(zapytanie)
